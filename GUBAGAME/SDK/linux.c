#include <directfb.h>#include <direct/util.h>#include <time.h>#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <math.h>#include <fcntl.h> #include <linux/fb.h>#include <sys/mman.h>#include <sys/ioctl.h>#include <alsa/asoundlib.h>#include "mplay.h"#include <pthread.h>#include "so.h"    // Windows specific functions and definitions#include "sound.h"//#include "game.h"#include "dirent.h"#include <sys/dir.h>#include <unistd.h>#define SND_BUFSIZE  256 //4096#define SND_HEADERS  8#define ROOTPATH "/mnt/data/"#define DEMOPATH "/mnt/data/jogos/MegaDrive/"//Heri begin - MegaDrive frame buffer control #define MDFBIOSET_DEINTERLACE		0x5600#define MDFBIOSET_INTERLACE		0x5601#define MDFBIOGET_VERTICALCOUNT		0x5602#define MDFBIOGET_NEXTFIELDPTR		0x5603#define MDFBIOSET_NEXTFIELDPTR		0x5604pixel *fieldptr[4];//Heri end#define IHW_TVENC_ADDRBASE 0x80038000#define IHW_LCDIF_ADDRBASE 0x80030000#define IHW_AUDIOOUT_ADDRBASE 0x80048000 //0x800480e0#define IHW_CLKCTRL_ADDRBASE  0x80040000#define IHW_PXP_ADDRBASE 0x8002A000#define IHW_POWER_ADDRBASE 0x80044000#define IHW_OCOTP_ADDRBASE 0x8002C000#define ADDRFRAMEK 0x41400000 #define TU 4#define IHW_PXP_CTRL 0x0/TU#define IHW_PXP_CTRL_CLR 0x8/TU#define IHW_PXP_CTRL_SET 0x4/TU#define IHW_PXP_CTRL_TOG 0xC/TU#define IHW_PXP_RGBBUF 0x20/TU#define IHW_PXP_RGBSIZE 0x40/TU#define IHW_PXP_S0BUF 0x50/TU#define IHW_PXP_S0PARAM 0x80/TU#define IHW_PXP_S0BACKGROUND 0x90/TU #define IHW_PXP_S0CROP 0xA0/TU#define IHW_PXP_OL0PARAM 0x220/TU#define IHW_PXP_OL1PARAM 0x260/TU#define IHW_PXP_OL2PARAM 0x2a0/TU#define IHW_PXP_OL3PARAM 0x2e0/TU#define IHW_PXP_OL4PARAM 0x320/TU#define IHW_PXP_OL5PARAM 0x360/TU#define IHW_PXP_OL6PARAM 0x3a0/TU#define IHW_PXP_OL7PARAM 0x3e0/TU#define IHW_PXP_STAT 0x10/TU#define IHW_PXP_S0UBUF 0x60/TU#define IHW_PXP_S0VBUF 0x70/TU#define IHW_PXP_S0SCALE 0xB0/TU#define IHW_PXP_S0OFFSET 0xC0/TU#define IHW_PXP_CSCCOEFF0 0xD0/TU#define IHW_PXP_CSCCOEFF1 0xE0/TU#define IHW_PXP_CSCCOEFF2 0xF0/TU#define IHW_LCDIF_VDCTRL4 0xb0/TU#define IHW_LCDIF_CTRL    0x00/TU#define IHW_LCDIF_CTRL_SET 0x04/TU#define IHW_LCDIF_CTRL1   0x10/TU#define IHW_LCDIF_CUR_BUF 0x30/TU#define IHW_LCDIF_DATA    0x1b0/TU#define IHW_LCDIF_DVICTRL0 0xc0/TU#define IHW_LCDIF_DVICTRL1 0xd0/TU#define IHW_LCDIF_DVICTRL2 0xe0/TU#define IHW_LCDIF_DVICTRL3 0xf0/TU#define IHW_LCDIF_DVICTRL4 0x100/TU#define IHW_LCDIF_NEXT_BUF 0x40/TU#define IHW_LCDIF_STAT     0x1d0/TU#define IHW_LCDIF_TIMING   0x60/TU#define IHW_LCDIF_TRANSFER_COUNT 0x20/TU#define IHW_LCDIF_VDCTRL0 0x70/TU#define IHW_LCDIF_VDCTRL1 0x80/TU#define IHW_LCDIF_VDCTRL2 0x90/TU#define IHW_LCDIF_VDCTRL3 0xa0/TU#define IHW_LCDIF_VDCTRL4 0xb0/TU#define IHW_TVENC_CONFIG 0x10/TU#define IHW_TVENC_SYNCOFFSET 0x30/TU#define IHW_TVENC_COLORBURST 0x140/TU#define IHW_TVENC_COLORSUB0 0xc0/TU#define IHW_TVENC_COLORSUB1 0xd0/TU#define IHW_AUDIOOUT_DATA 0xf0/TU#define IHW_AUDIOOUT_CTRL 0x0/TU#define IHW_AUDIOOUT_CTRL_SET 0x4/TU#define IHW_AUDIOOUT_DACVOLUME 0x30/TU#define IHW_AUDIOOUT_HPVOL 0x50/TU#define IHW_AUDIOOUT_SPEAKERCTRL 0x100/TU#define IHW_POWER_CTRL 0x00/TU#define IHW_POWER_STS 0x0C0/TU#define IHW_OCOTP_CTRL 0x00/TU#define IHW_OCOTP_ROM0 0x01A0/TU#define IHW_CLKCTRL_CPU 0x020/TU#define IHW_CLKCTRL_PIX 0x60/TU#define IHW_CLKCTRL_HBUS 0x030/TU#define IHW_CLKCTRL_XBUS 0x040/TU#define IHW_CLKCTRL_XTAL 0x050/TU#define IHW_CLKCTRL_SSP  0x070/TU#define IHW_CLKCTRL_EMI  0x0a0/TU#define IHW_CLKCTRL_FRAC 0x0f0/TU#define IHW_CLKCTRL_RESET 0x120/TU/*                        HW_CLKCTRL_CLKSEQ                             0x80040110                        HW_CLKCTRL_CLKSEQ_CLR                         0x80040118                        HW_CLKCTRL_CLKSEQ_SET                         0x80040114                        HW_CLKCTRL_CLKSEQ_TOG                         0x8004011c                        HW_CLKCTRL_CPU                                0x80040020                        HW_CLKCTRL_CPU_CLR                            0x80040028                        HW_CLKCTRL_CPU_SET                            0x80040024                        HW_CLKCTRL_CPU_TOG                            0x8004002c                        HW_CLKCTRL_EMI                                0x800400a0                        HW_CLKCTRL_ETM                                0x800400e0                        HW_CLKCTRL_FRAC                               0x800400f0                        HW_CLKCTRL_FRAC_CLR                           0x800400f8                        HW_CLKCTRL_FRAC_SET                           0x800400f4                        HW_CLKCTRL_FRAC_TOG                           0x800400fC                        HW_CLKCTRL_FRAC1                              0x80040100                        HW_CLKCTRL_FRAC1_CLR                          0x80040108                        HW_CLKCTRL_FRAC1_SET                          0x80040104                        HW_CLKCTRL_FRAC1_TOG                          0x8004010C                        HW_CLKCTRL_GPMI                               0x80040080                        HW_CLKCTRL_HBUS                               0x80040030                        HW_CLKCTRL_HBUS_CLR                           0x80040038                        HW_CLKCTRL_HBUS_SET                           0x80040034               HW_CLKCTRL_HBUS_TOG                      0x8004003c               HW_CLKCTRL_IR                            0x800400b0               HW_CLKCTRL_PIX                           0x80040060               HW_CLKCTRL_PLLCTRL0                      0x80040000               HW_CLKCTRL_PLLCTRL0_CLR                  0x80040008               HW_CLKCTRL_PLLCTRL0_SET                  0x80040004               HW_CLKCTRL_PLLCTRL0_TOG                  0x8004000C               HW_CLKCTRL_PLLCTRL1                      0x80040010               HW_CLKCTRL_RESET                         0x80040120               HW_CLKCTRL_SAIF                          0x800400c0               HW_CLKCTRL_SPDIF                         0x80040090               HW_CLKCTRL_SSP                           0x80040070               HW_CLKCTRL_STATUS                        0x80040130               HW_CLKCTRL_TV                            0x800400d0               HW_CLKCTRL_VERSION                       0x80040140               HW_CLKCTRL_XBUS                          0x80040040               HW_CLKCTRL_XTAL                          0x80040050               HW_CLKCTRL_XTAL_CLR                      0x80040058               HW_CLKCTRL_XTAL_SET                      0x80040054               HW_CLKCTRL_XTAL_TOG                      0x8004005C*/int HandleKeys(int Key,int Down);void PlayBuffers(void);// Main screen buffer pixel *ScrBuffer;  char kbp[10000];  int kbfd = 0;  unsigned long maskJoy=0,mJoy2=0;// Joystick state unsigned int JoyState;int flgRenderAudioPreview=0;unsigned short silenc[2000];// Filename char Filename[256];// Audio buffer sample SndBuffer[SND_BUFSIZE]; sample *SndWPtr,*SndRPtr; int CurHdr;// Timer variables int TimerID; int TimerReady;tmouse mouse; long currentTime=0; long timeJoyRecovery=0; long timeUSBRecovery=0; static int fbfd = 0; static struct fb_var_screeninfo vinfo; static struct fb_fix_screeninfo finfo; static long int screensize = 0;  //static char *fbp,*fbptr= 0; char *fbpOrig;  //static  long int location =0;//  static int x = 200, y =120; static int x = 40, y =0;int szline;long long tempo,now,tempof,tempop;long dif,diff;int fpsc,cf,fpsg,cfg;int statusDraw;int countSound;volatile u32 audiooutBKP[0x100];volatile u32 *pxp,*tvenc,*lcdif,*audioout,*clkctrl,*power,*ocotp;volatile u32 *frameK;int X_RES=19760; //40000; //720; int Y_RES=494; //500; //480;int H_BLANKING=262;int V_LINES=525;int X_BORDER=0;int SYNC_OFFSET=857;unsigned long COLORSUB0=568784038; //0x21E6EFE3;unsigned long COLORSUB1=0;unsigned long COLORBURST=0xd62a0000;unsigned long CONFIG=0x0C000240;unsigned long CLKCTRL_PIX;unsigned long TRANSFER_COUNT,DVICTRL0,DVICTRL1,DVICTRL2,DVICTRL3,DVICTRL4,TSYNC_OFFSET,TCOLORSUB0,LCDIFCTRL,LCDIFCTRL1;unsigned long DACVOLUME;long memoBusy=0;int flagMute=0;typedef struct _mapMalloc{	void *p;	long size;} mapMalloc;int idxListMalloc;mapMalloc listMalloc[10000]; int comp(const void *s1, const void *s2); static void initFB(void);int mapHW(void);int VVIDEO_WIDTH = VIDEO_WIDTH;  
int VVIDEO_HEIGHT = VIDEO_HEIGHT;

void setActualView(int w,int h)
{
	VVIDEO_WIDTH=w;
	VVIDEO_HEIGHT=h;
}//int initVideo( int argc, char *argv[] )int mapHW(void){     int     quit = 0;     int     clipping = 0;     int t,y;     u32 *bf;      size_t length = 0x1000;    // 4KB page     int prot = PROT_READ | PROT_WRITE;     int flags = MAP_SHARED;     int fd = open("/dev/mem", O_RDWR ) ;     off_t offset;     unsigned int offset_addr;     int index;        if (fd < 0) {              printf("open Failed\n");              return 1;        }        offset_addr=IHW_TVENC_ADDRBASE;        offset = (off_t)(offset_addr & 0xfffff000);        index = offset_addr & 0xfff;        tvenc = (u32 *)mmap(NULL, length, prot, flags, fd, offset);        if (tvenc == MAP_FAILED) {              printf("mmap Failed\n");              return 4;        }	printf("Memoria TVENC %x\n",tvenc);        offset_addr=IHW_LCDIF_ADDRBASE;        offset = (off_t)(offset_addr & 0xfffff000);        index = offset_addr & 0xfff;	lcdif = (u32 *)mmap(NULL, length, prot, flags, fd, offset);        if (lcdif == MAP_FAILED) {              printf("mmap Failed\n");              return 4;        }	printf("Memoria LCDIF %x\n",lcdif);	offset_addr=IHW_AUDIOOUT_ADDRBASE;        offset = (off_t)(offset_addr & 0xfffff000);        index = offset_addr & 0xfff;        audioout = (u32 *)mmap(NULL, length, prot, flags, fd, offset);        if (audioout == MAP_FAILED) {              printf("mmap Failed\n");              return 4;        }	printf("Memoria AUDIOOUT %x\n",audioout);	offset_addr=IHW_CLKCTRL_ADDRBASE;        offset = (off_t)(offset_addr & 0xfffff000);        index = offset_addr & 0xfff;        clkctrl = (u32 *)mmap(NULL, length, prot, flags, fd, offset);        if (clkctrl == MAP_FAILED) {              printf("mmap Failed\n");              return 4;        }	printf("Memoria CLKCTRL %x\n",clkctrl);	offset_addr=ADDRFRAMEK;        offset = (off_t)(offset_addr & 0xfffff000);        index = offset_addr & 0xfff;	length =  720*480*4*3; //640*480*4; //320*240*4;	frameK = (u32 *)mmap(NULL, length, prot, flags, fd, offset);	length = 0x1000;  // volta o tamanho padrao	if (frameK == MAP_FAILED) {              printf("mmap Failed 2\n");              return 4;        }	printf("Memoria FRAMEK %x\n",frameK); 	offset_addr=IHW_PXP_ADDRBASE;        offset = (off_t)(offset_addr & 0xfffff000);        index = offset_addr & 0xfff;        pxp = (u32 *)mmap(NULL, length, prot, flags, fd, offset);        if (pxp == MAP_FAILED) {              printf("mmap Failed\n");              return 4;        }	printf("Memoria PXP %x\n",pxp); 	offset_addr=IHW_POWER_ADDRBASE;        offset = (off_t)(offset_addr & 0xfffff000);        index = offset_addr & 0xfff;        power = (u32 *)mmap(NULL, length, prot, flags, fd, offset);        if (power == MAP_FAILED) {              printf("mmap Failed\n");              return 4;        }	printf("Memoria POWER %x\n",power); 	offset_addr=IHW_OCOTP_ADDRBASE;        offset = (off_t)(offset_addr & 0xfffff000);        index = offset_addr & 0xfff;        ocotp = (u32 *)mmap(NULL, length, prot, flags, fd, offset);        if (ocotp == MAP_FAILED) {              printf("mmap Failed\n");              return 4;        }	printf("Memoria OCOTP %x\n",ocotp);//Heri init mult-field buffer/*	fieldptr[0] = (pixel *)mmap(NULL, 1382400, prot, flags, fd,0x41E00000);	if (fieldptr[0] == MAP_FAILED) { 		printf("Mult Field Buffer mmap Failed for 0x41E00000\n"); 		return 4;	}	fieldptr[1] = (pixel *)mmap(NULL, 1382400, prot, flags, fd,0x41400000);	if (fieldptr[1] == MAP_FAILED) { 		printf("Mult Field Buffer mmap Failed for 0x41400000,\n"); 		return 4;	}	fieldptr[2]=fieldptr[0]+(720);	fieldptr[3]=fieldptr[1]+(720);*///Heri/*	location = 45700;	szline = 720;	CONFIG=tvenc[IHW_TVENC_CONFIG];	CLKCTRL_PIX=clkctrl[IHW_CLKCTRL_PIX];	if(argc>2) CONFIG=atoi(argv[2]); //X_RES=atoi(argv[2]);     	if(argc>3) CLKCTRL_PIX=atoi(argv[3]); //Y_RES=atoi(argv[3]);     	if(argc>4) H_BLANKING=atoi(argv[4]);     	if(argc>5) V_LINES=atoi(argv[5]);	if(argc>6) szline=atoi(argv[6]);	if(argc>7) X_BORDER=atoi(argv[7]);	if(argc>8) location=atoi(argv[8]);	if(argc>9)  COLORSUB0=atoi(argv[9]);	//if(argc>10) SYNC_OFFSET=atol(argv[10]);	if(argc>10) COLORSUB1=atol(argv[10]);	if(argc>11) COLORBURST=atol(argv[11]);//	printf("720x240 %d %d %d %d %d %d %d %d %d %ud   \n",X_RES,Y_RES,H_BLANKING,V_LINES,szline,X_BORDER,location,COLORSUB0,COLORSUB1,COLORBURST); 	printf("720x240 %x %x %d %d %d %d %d %d %d %ud   \n",CONFIG,CLKCTRL_PIX,H_BLANKING,V_LINES,szline,X_BORDER,location,COLORSUB0,COLORSUB1,COLORBURST); 		lcdif[IHW_LCDIF_TRANSFER_COUNT]=((Y_RES<<16)| (X_RES)); 	lcdif[IHW_LCDIF_DVICTRL0]=((1440<<20) | (H_BLANKING<<10) | (V_LINES) ); 	lcdif[IHW_LCDIF_DVICTRL1]= ((1<<20) | ((V_LINES/2)<<10) | ((V_LINES/2)+1)); 	lcdif[IHW_LCDIF_DVICTRL2]=((V_LINES<<20) | ((V_LINES/2)<<10) | ((V_LINES/2)+((V_LINES-Y_RES)/2)));	lcdif[IHW_LCDIF_DVICTRL3]=( (V_LINES<<16)  | ( (V_LINES+(V_LINES-Y_RES)/2-1)%V_LINES));	//lcdif[IHW_LCDIF_DVICTRL4]=((16<<24) | (128<<16) | (128<<8) | (720-X_RES));	lcdif[IHW_LCDIF_DVICTRL4]=((16<<24) | (128<<16) | (128<<8) | (X_BORDER));		lcdif[IHW_LCDIF_VDCTRL0]=0; // Nao altera nada	lcdif[IHW_LCDIF_VDCTRL1]=0;	lcdif[IHW_LCDIF_VDCTRL2]=0;	lcdif[IHW_LCDIF_VDCTRL3]=0;	lcdif[IHW_LCDIF_VDCTRL4]=0;	tvenc[IHW_TVENC_CONFIG]=CONFIG; //0x0C000240;	tvenc[IHW_TVENC_SYNCOFFSET]=SYNC_OFFSET; //0x00000359;	tvenc[IHW_TVENC_COLORSUB0]=COLORSUB0;	//tvenc[IHW_TVENC_COLORSUB1]=COLORSUB1;	//tvenc[IHW_TVENC_COLORBURST]=COLORBURST; */	mute(0);	memcpy(audiooutBKP,audioout,0x100*4);}static void initFB(void){int c; unsigned long ctr;  fbfd = open("/dev/fb0", O_RDWR);  if (!fbfd){  	printf("Fb:cannot open framebuffer device. \n");	return(0);  }  if (ioctl(fbfd,FBIOGET_FSCREENINFO, &finfo)){  	printf("Fb:error reading fixed information \n");	return(0);  }  if (ioctl(fbfd,FBIOGET_VSCREENINFO, &vinfo)){  	printf("Fb:error reading variable information \n");	return(0);  }  screensize = vinfo.xres * vinfo.yres * vinfo.bits_per_pixel /8 ;  fbp = (char*)mmap(0,screensize,PROT_READ | PROT_WRITE, MAP_SHARED, fbfd, 0 );  if ((int)fbp == -1) {  	printf("Fb:failed to map framebuffer device to memory. \n");	return(0);  }  location = (x+vinfo.xoffset) * (vinfo.bits_per_pixel / 8 ) +             (y+vinfo.yoffset) * (finfo.line_length); fbptr=fbp+location;  fbpOrig=fbp;#if SWAPVIDEO 	lcdif[IHW_LCDIF_CUR_BUF]=finfo.smem_start;	lcdif[IHW_LCDIF_NEXT_BUF]=finfo.smem_start;	fbp=frameK;#endif	ctr=lcdif[IHW_LCDIF_CTRL];	//lcdif[IHW_LCDIF_CTRL]|=0x00000F00;	//lcdif[IHW_LCDIF_CTRL]=0x001900a8;	//lcdif[IHW_LCDIF_TRANSFER_COUNT]=0x01e000B4;	printf("LCDIF %x - %x\n",lcdif[IHW_LCDIF_CTRL],lcdif[IHW_LCDIF_TRANSFER_COUNT]);/*  for(c=0;c<480;c++)  {	memset(fbptr,0xFFFFFF,640*4);        fbptr+=720*4;  }  */}static void initKB(void){ int c;// int   kbfd = 0;  #if USBJOY   kbfd = open("/dev/input/js2", O_RDONLY | O_NONBLOCK);  if (!kbfd){  	printf("Kb:cannot open Keyboard device. \n");	return(0);  }  /*kbp = (char*)mmap(0,0x1000,PROT_READ, MAP_FIXED, kbfd, 0 );  if ((int)kbp == -1) {  	printf("Kb:failed to map Keyboard device to memory. \n");	return(0);  } */#else	InitJoy();#endif}int getKB(void){int ts,i; char *bp; DIR *dp; struct dirent *entry; int flgRec=0; unsigned int j; unsigned short Joy1=0; unsigned long Joy2=0;#if USBJOY	if(getCurrentTime()-timeJoyRecovery>2000)	{		timeJoyRecovery=getCurrentTime();		dp = opendir("/dev/input/");		if (dp != NULL)		{				i=0;			while((entry = readdir(dp)))			{				if(strstr(entry->d_name,"js2")) 				{					i=1;					if(kbfd==0)					 flgRec=1;					break;				}			}			if(i==0) kbfd=0;			closedir(dp);		}	}	if(flgRec)	{		initKB();	}	if(kbfd)	{		ts=read(kbfd, kbp, 9000);		//ts=read(kbfd, kbp, 10);		if(ts>0)		{			//printf("KB %d::",ts);			bp=kbp;			for(i=0;i<ts;i+=8)			{				if(bp[6]==1)				{					if(bp[4]==1)					{						if(bp[7]==0) mJoy2|=0x0010;						if(bp[7]==1) mJoy2|=0x0020;						if(bp[7]==2) mJoy2|=0x0040;						if(bp[7]==9) mJoy2|=0x0080;					}					else					{							if(bp[7]==0) mJoy2&=0xFFEF;						if(bp[7]==1) mJoy2&=0xFFDF;						if(bp[7]==2) mJoy2&=0xFFBF;						if(bp[7]==9) mJoy2&=0xFF7F;					}						}				else				{					if(bp[4]==0)					{					   if(bp[7]==4)					   { 						mJoy2&=0xFFF3;					   }					   else					   { 					        mJoy2&=0xFFFC;					   }					}					else					{  		   			   if(bp[7]==4)					   { 					     if(bp[5]==127)					       mJoy2|=0x0004;					     else					       mJoy2|=0x0008;					   }					   else					   { 					     if(bp[5]==127)					       mJoy2|=0x0002;					     else					       mJoy2|=0x0001;					   }					}							}								bp+=8;			}				//printf("%d,",kbp[i]);			//printf("\n");			//printf("%x\n",maskJoy);		}	}	maskJoy=mJoy2;#else	j=ReadJoy();	//j=0xFFFFFFFF;//Joy 1	if(j & 0x00000010) Joy1&=~0x0001;	else	  	   Joy1|=0x0001;	if(j & 0x00000020) Joy1&=~0x0004;	else	  	   Joy1|=0x0004;	if(j & 0x00000040) Joy1&=~0x0100;	else	  	   Joy1|=0x0100;	if(j & 0x00000080) Joy1&=~0x0200;	else	  	   Joy1|=0x0200;	if(j & 0x00001000) Joy1&=~0x0008;	else	  	   Joy1|=0x0008;	if(j & 0x00002000) Joy1&=~0x0002;	else		   Joy1|=0x0002;	if(j & 0x00004000) Joy1&=~0x0010;	else		   Joy1|=0x0010;	if(j & 0x00008000) Joy1&=~0x0020;	else		   Joy1|=0x0020;	if(j & 0x00020000) Joy1&=~0x0080;	else		   Joy1|=0x0080;	if(j & 0x00200000) Joy1&=~0x0400;	else		   Joy1|=0x0400;	if(j & 0x20000000) Joy1&=~0x0040;	else		   Joy1|=0x0040;//Joy 2	if(j & 0x00000001) Joy2&=~0x0001;	else	  	   Joy2|=0x0001;	if(j & 0x00000002) Joy2&=~0x0004;	else	  	   Joy2|=0x0004;	if(j & 0x00000004) Joy2&=~0x0100;	else	  	   Joy2|=0x0100;	if(j & 0x00000008) Joy2&=~0x0200;	else	  	   Joy2|=0x0200;	if(j & 0x00000100) Joy2&=~0x0008;	else	  	   Joy2|=0x0008;	if(j & 0x00000200) Joy2&=~0x0002;	else		   Joy2|=0x0002;	if(j & 0x00000400) Joy2&=~0x0010;	else		   Joy2|=0x0010;	if(j & 0x00000800) Joy2&=~0x0020;	else		   Joy2|=0x0020;	if(j & 0x00010000) Joy2&=~0x0080;	else		   Joy2|=0x0080;	if(j & 0x00100000) Joy2&=~0x0400;	else		   Joy2|=0x0400;	if(j & 0x10000000) Joy2&=~0x0040;	else		   Joy2|=0x0040;	maskJoy=Joy1|Joy2;#endif	return maskJoy;}//void mute(void)void mute(int i){unsigned long audio;//	printf("GUERTA DESLIGA O SOM AQUIIIIIIIIIIIII %d \n",i);#if NOSOUND==0	audio=audioout[IHW_AUDIOOUT_CTRL];	audio|=0x00000020;	audioout[IHW_AUDIOOUT_CTRL]=audio;	flagMute=1;/*	audio=audioout[IHW_AUDIOOUT_DACVOLUME];	audio|=0x01000100;	audioout[IHW_AUDIOOUT_DACVOLUME]=audio;		audio=audioout[IHW_AUDIOOUT_HPVOL];	audio|=0x01000000;	audioout[IHW_AUDIOOUT_HPVOL]=audio;	audio=audioout[IHW_AUDIOOUT_SPEAKERCTRL];	audio|=0x01000000;	audioout[IHW_AUDIOOUT_SPEAKERCTRL]=audio;*/#endif	printf("DESLIGOU SUCESSO %d\n",i);}void resumeMute(void){unsigned long audio;#if NOSOUND==0/*	audio=audioout[IHW_AUDIOOUT_DACVOLUME];	audio&=0xfefffeff;	audioout[IHW_AUDIOOUT_DACVOLUME]=audio;	audio=audioout[IHW_AUDIOOUT_HPVOL];	audio&=0xfeffffff;	audioout[IHW_AUDIOOUT_HPVOL]=audio;	audio=audioout[IHW_AUDIOOUT_SPEAKERCTRL];	audio&=0xfeffffff;	audioout[IHW_AUDIOOUT_SPEAKERCTRL]=audio;*/	audio=audioout[IHW_AUDIOOUT_CTRL];	audio&=0xffffffdf;	audioout[IHW_AUDIOOUT_CTRL]=audio;	flagMute=0;#endif}//int Application(const char *CmdLine)int main(int argc, char *argv[]){	mapHW();	initFB();//Heri begin - Desentrelaça varredura//tvenc[IHW_TVENC_COLORSUB0]=0x21E65A30; //Croma sem trimilique neste modo//ioctl(fbfd, MDFBIOSET_DEINTERLACE,NULL);//Mega Drive FB IOCTL//Heri end	initKB();#if NOSOUND==0#if INITMPLAY==1	if(initPlaySound())		printf("ERRO AO INICIALIZAR SOM \n");#endif	printf("DAC %x AUDIO %x \n", DACVOLUME,audioout[IHW_AUDIOOUT_CTRL]);#endif        tempo = direct_clock_get_micros();        tempop= tempo;		tempof= tempo;                cf=0;          	diff=0;	cfg=0;	fpsc=0;	fpsg=0;  	SndWPtr     = SndBuffer+1;  	SndRPtr     = SndBuffer;  	memset(SndBuffer,0,SND_BUFSIZE*sizeof(sample));	statusDraw=0;	countSound=0;	//gameMain();	//menuMain();	Application(argv[1]);}/** PlayBuffers() ********************************************//** This internal function plays ready audio buffers.       **//*************************************************************/ void PlayBuffers(void){ }/*============================================================ F: Get mouse information =============================================================*/tmouse * getMouseInf(void){	return &mouse; }/*============================================================ F: Set mouse information =============================================================*/void setMousePosition(tmouse * mo){	mouse.x=mo->x;	mouse.y=mo->y;}/** HandleKeys() *********************************************//** Handle key presses/releases. Returns 1 if a key was     **//** recognized, 0 otherwise.                                **//*************************************************************/ int HandleKeys(int Key,int Down){    /* Done */  return(0);}//** GetVideo() *****************************************************//** Get address of the video buffer that can be written by your   **//** program, i.e. currently INACTIVE video buffer. The other two  **//** functions return active (front) and inactive (back) buffers.  **//*******************************************************************#if PXPOFF/*#if RESOLUTION==666pixel *GetVideo(void){ extern int fbfd;extern pixel *fieldptr[4];unsigned int NextFreeField;while(	ioctl(fbfd, MDFBIOGET_NEXTFIELDPTR, (unsigned int)&NextFreeField) !=0 ){}return(fieldptr[NextFreeField]+location/4);}#else */pixel *GetVideo(void) {/*unsigned int NextFreeField;ioctl(fbfd, MDFBIOGET_NEXTFIELDPTR, (unsigned int)&NextFreeField);printf("VIDEO %d \n",NextFreeField);*/ return(fbp); }//#endif#elsepixel *GetVideo(void) { return(frameK); } #endif//{ return(ScrBuffer); }pixel *GetFrontVideo(void) { return(ScrBuffer); }pixel *GetBackVideo(void) { return(ScrBuffer); }//** GetVideoWidth()/GetVideoHeight() *******************************//** Get video buffer dimensions.                                  **//*******************************************************************int GetVideoWidth(void) { return(VVIDEO_WIDTH); }int GetVideoHeight(void) { return(VVIDEO_HEIGHT); }//** FlipVideo() ****************************************************//** Switch displayed video buffer from VBUF0 to VBUF1 and back.   **//** Returns the address of the INACTIVE video buffer that can be  **//** modified by your program. The ACTIVE video buffer cannot be   **//** written to.                                                   **//*******************************************************************int fr=0;pixel *FlipVideo(void){unsigned long ctr;//BOTAO POWER STATUS	//printf("STATUS BOTAO %x\n",power[IHW_POWER_STS]);	//ctr=power[IHW_POWER_STS];	//ctr=power[IHW_POWER_CTRL];	//ctr|=0x0F0000;	//power[IHW_POWER_CTRL]=ctr;	//printf("CTR %x\n",power[IHW_POWER_CTRL]);//APAGA LED	//ctr=ocotp[IHW_OCOTP_ROM0];	//ctr|=0xFFFFFFFF;	//ocotp[IHW_OCOTP_ROM0]=ctr;	//printf("CTR %x\n",ctr);//	ctr=lcdif[IHW_LCDIF_CTRL1];//	ctr=0x1070301;//	lcdif[IHW_LCDIF_CTRL1]=ctr;//	printf("CTR %x\n",ctr);#if WAITVBLANK	while((lcdif[IHW_LCDIF_STAT] & 0x01000000));	//if((lcdif[IHW_LCDIF_STAT] & 0x01000000)) return 1;#endif#if PXPOFF#if SWAPVIDEO	if(fbp==frameK)	{		lcdif[IHW_LCDIF_CUR_BUF]=ADDRFRAMEK;		lcdif[IHW_LCDIF_NEXT_BUF]=ADDRFRAMEK;			fbp=fbpOrig;	}	else	{		lcdif[IHW_LCDIF_CUR_BUF]=finfo.smem_start;		lcdif[IHW_LCDIF_NEXT_BUF]=finfo.smem_start;		fbp=frameK;	}#endif	return 0;#endif  	if(fr==0)	{	fr=1;	pxp[IHW_PXP_RGBBUF]=(u32 *)finfo.smem_start;	pxp[IHW_PXP_RGBSIZE]=0xFF2D01E0; //720x480	//pxp[IHW_PXP_RGBSIZE]=0xFF2D0190; //720x400	//pxp[IHW_PXP_RGBSIZE]=0xFF2D00F0; //720x240	pxp[IHW_PXP_S0BUF]=(u32 *)ADDRFRAMEK;	pxp[IHW_PXP_S0PARAM]=0x00005A3C; //(720x480) 	//pxp[IHW_PXP_S0PARAM]=0x00004B32; //(600x400) 	//pxp[IHW_PXP_S0PARAM]=0x00004B32; //(600x400) 	//pxp[IHW_PXP_S0PARAM]=0x0000281E; //(320x240)	pxp[IHW_PXP_S0BACKGROUND]=0; //0x0FF00000;	pxp[IHW_PXP_OL0PARAM]=0x00000000;	pxp[IHW_PXP_OL1PARAM]=0x00000000;	pxp[IHW_PXP_OL2PARAM]=0x00000000;	pxp[IHW_PXP_OL3PARAM]=0x00000000;	pxp[IHW_PXP_OL4PARAM]=0x00000000;	pxp[IHW_PXP_OL5PARAM]=0x00000000;	pxp[IHW_PXP_OL6PARAM]=0x00000000;	pxp[IHW_PXP_OL7PARAM]=0x00000000; 	}	pxp[IHW_PXP_S0BUF]=(u32 *)ADDRFRAMEK;	//pxp[IHW_PXP_CTRL]=0x00001001;	pxp[IHW_PXP_CTRL]=0x00001001;  // Done  //return(ScrBuffer);    return 0;}//** RequestFlip() **************************************************//** Request a video buffer flip. The FlipReady() function will    **//** return 1 as soon as the video buffers have been flipped. Use  **//** RequestFlip()/FlipRead() functions instead of the FlipVideo() **//** function when you wish to do computations while waiting for   **//** the buffers to be flipped.                                    **//*******************************************************************void RequestFlip(void) { FlipVideo(); }//** FlipReady() ****************************************************//** This function will return new buffer address as soon as the   **//** video buffers are flipped after a call to RequestFlip(). It   **//** returns 0 otherwise.                                          **//*******************************************************************pixel *FlipReady(void) { return(ScrBuffer); }//** GetJoystick() **************************************************//** Get the state of joypad buttons (1 means "pressed"). Refer to **//** the BTN_* #defines for the button mapping information. Notice **//** that on Windows this function automatically calls ProcessMsgs **//** to process Windows messages.                                  **//*******************************************************************unsigned int GetJoystick(void){  JoyState=getKB();  return(JoyState);}//** WaitJoystick() *************************************************//** Wait until one or more of the buttons given in the Mask have  **//** been pressed. Returns the bitmask of pressed buttons. This    **//** function will also eliminate jitter. Refer to BTN_* #defines  **//** for the button mapping information.                           **//*******************************************************************unsigned int WaitJoystick(unsigned int Mask){  return(0);}//** GetAudio() *****************************************************//** Get base address of the audio buffer.                         **//*******************************************************************sample *GetAudio(void) { return(SndBuffer); }//** GetTotalAudio() ************************************************//** Get the total length of the audio buffer, in samples.         **//*******************************************************************unsigned int GetTotalAudio(void) { return(sizeof(SndBuffer)); }//** GetFreeAudio() *************************************************//** Get the amount of free space in the audio buffer, in samples. **//*******************************************************************unsigned int GetFreeAudio(void){  int J;  J=(int)(SndRPtr-SndWPtr);  return(J>0? J:J+SND_BUFSIZE);}//** WriteAudio() ***************************************************//** Write up to a given number of samples into the audio buffer.  **//** Returns the number of samples written.                        **//*******************************************************************unsigned int WriteAudio(sample *Data,unsigned int Length){ int i; /* unsigned int J;  // Can't write more than the free space  J=GetFreeAudio();  if(J<Length) Length=J;  // Copy data  for(J=0;J<Length;J++)  {    *SndWPtr++=Data[J];    if(SndWPtr-SndBuffer>=SND_BUFSIZE) SndWPtr=SndBuffer;  }  // Enqueue buffers ready to play  PlayBuffers(); */  bufferPlay(Data,Length);//    for(i=0;i<Length;i++)  //  {	//audioout[IHW_AUDIOOUT_DATA]=(Data[i]<<16 | //Data[i]);    //}	  // Done  return(Length);}//** WaitSyncTimer() ************************************************//** Wait for the timer to become ready.                           **//*******************************************************************void WaitSyncTimer(void){  TimerReady=0;}//** SetSyncTimer() *************************************************//** Set synchronization timer to a given frequency in Hz.         **//*******************************************************************int SetSyncTimer(int Hz){   /* Return allocated timer ID */  return(TimerID);}/*=================================================F: Test file exist===================================================*/int testFileExist(char *nameFile) {FILE *arq; int ret=0;   arq=fopen(nameFile,"rb");  if(arq)  {	ret=1;	fclose(arq);  }  return ret; }/*=================================================F: Read a file ===================================================*/long readFile(char *nameFile, char **buf) {  FILE *arq;  long size=-1;  char *b;  arq=fopen(nameFile,"rb");  if(arq)  {	fseek(arq, 0, SEEK_END); // seek to end of file	size = ftell(arq); // get current file pointer	fseek(arq, 0, SEEK_SET); 	b=malloc(size);	if(b)	{		size=(long)fread(b,1,size,arq);	}	*buf=b;	fclose(arq);  }  return size ;}/*=================================================F: Read a file limit size===================================================*/long readFileChunk(char *nameFile, char **buf,int seek,int size) {  FILE *arq;  char *b;  int rsize=-1;  arq=fopen(nameFile,"rb");  if(arq)  {	fseek(arq, seek, SEEK_SET); 	b=*buf;	if(b==0) 		b=malloc(size);	if(b)	{		rsize=(long)fread(b,1,size,arq);	}	*buf=b;	fclose(arq);  }  return rsize ;}/*=================================================F: Get size malloc===================================================*/long  getSizeMalloc(void){	return memoBusy;}/*=================================================F: Malloc===================================================*/void * mymalloc(long size){int i; void *ret;	memoBusy+=size;	ret= malloc((size_t)size);	for (i=0;i<10000;i++)	{		if(listMalloc[i].p==0)		{			listMalloc[i].p=ret;			listMalloc[i].size=size;			break;		}	}	return ret;}/*=================================================F: FreeMalloc===================================================*/void myfree(void *p){int i;		for (i=0;i<10000;i++)	{		if(listMalloc[i].p==p)		{			memoBusy-=listMalloc[i].size;			listMalloc[i].p=0;			listMalloc[i].size=0;			break;		}	}	if(p) free(p);	p=0;}/*=================================================F: Get current time mileseconds===================================================*/long getCurrentTime(void){	currentTime=direct_clock_get_millis();	return currentTime;}int getDrawFrame(void){	now=direct_clock_get_micros(); //direct_clock_get_millis();	dif = now-tempof;	tempof=now;	dif+=diff;	diff=dif-16393; //dif-17;	if(diff>16393*10) diff=0; // para nao deixar atrasado demais	if(dif>16393) //dif>17) 	{		statusDraw=0;		return 0;	}	else	    	{	cfg++;	//	diff=0;		statusDraw=1;		return 1;	}}int getFPS(int * FPSG,int * FPS){	now=direct_clock_get_micros(); //direct_clock_get_millis();	dif = now-tempo;		if(dif>1000000) //1000)	{		fpsc=cf;		fpsg=cfg;		cf=0;		cfg=0;		tempo=now;	}	cf++;	dif=now-tempop;	if(dif>5000000) //5000)	{		tempop=now;		*FPS=fpsc;		*FPSG=fpsg;		return 1;	}	else	return 0;}void watchdog(long time){	usleep(time);	//printf("LIXO\n");}void stopSound(void){#if NOSOUND==0	closePlay();	flgRenderAudioPreview=0;	memcpy(audioout,audiooutBKP,0x100*4);#endif}void resumeSound(void){#if NOSOUND==0	mute(0); 	memcpy(audioout,audiooutBKP,0x100*4);	initPlaySound();	flgRenderAudioPreview=1;	#endif 	tempo = direct_clock_get_micros();        tempop= tempo;		tempof= tempo;                cf=0;          	diff=0;	cfg=0;	fpsc=0;	fpsg=0;}unsigned int NextFreeField;void resumeVideo(void){int c;     while((lcdif[IHW_LCDIF_STAT] & 0x01000000));     fbptr=fbp;     for(c=0;c<480;c++)     {	memset(fbptr,0x0,720*4);        fbptr+=720*4;     }         fbptr=frameK;     for(c=0;c<480;c++)     {	memset(fbptr,0x0,720*4);        fbptr+=720*4;     }       //  lcdif[IHW_LCDIF_CTRL]=LCDIFCTRL;   //  lcdif[IHW_LCDIF_CTRL1]=LCDIFCTRL1;     while((lcdif[IHW_LCDIF_STAT] & 0x01000000));     lcdif[IHW_LCDIF_TRANSFER_COUNT]=TRANSFER_COUNT;     lcdif[IHW_LCDIF_DVICTRL0]=DVICTRL0;     lcdif[IHW_LCDIF_DVICTRL1]=DVICTRL1;     lcdif[IHW_LCDIF_DVICTRL2]=DVICTRL2;     lcdif[IHW_LCDIF_DVICTRL3]=DVICTRL3;     lcdif[IHW_LCDIF_DVICTRL4]=DVICTRL4; //    lcdif[IHW_LCDIF_VDCTRL0]=0; // Nao altera nada //    lcdif[IHW_LCDIF_VDCTRL1]=0;  //   lcdif[IHW_LCDIF_VDCTRL2]=0;  //   lcdif[IHW_LCDIF_VDCTRL3]=0;  //   lcdif[IHW_LCDIF_VDCTRL4]=0;  //   tvenc[IHW_TVENC_CONFIG]=CONFIG; //0x0C000240;  //   tvenc[IHW_TVENC_SYNCOFFSET]=TSYNC_OFFSET; #if RESOLUTION==666 //Heri begin -	tvenc[IHW_TVENC_COLORSUB0]=TCOLORSUB0;	ioctl(fbfd, MDFBIOSET_INTERLACE,NULL);	//NextFreeField=0;	//ioctl(fbfd, MDFBIOSET_NEXTFIELDPTR,(unsigned int)&NextFreeField);//Heri end#endif     }void waitVBLANK(){	while((lcdif[IHW_LCDIF_STAT] & 0x01000000));}void saveVideo(void){	while((lcdif[IHW_LCDIF_STAT] & 0x01000000));	//CONFIG=tvenc[IHW_TVENC_CONFIG];	TRANSFER_COUNT=lcdif[IHW_LCDIF_TRANSFER_COUNT];	DVICTRL0=lcdif[IHW_LCDIF_DVICTRL0];	DVICTRL1=lcdif[IHW_LCDIF_DVICTRL1];	DVICTRL2=lcdif[IHW_LCDIF_DVICTRL2];	DVICTRL3=lcdif[IHW_LCDIF_DVICTRL3];	DVICTRL4=lcdif[IHW_LCDIF_DVICTRL4];	//TSYNC_OFFSET=tvenc[IHW_TVENC_SYNCOFFSET]; 	TCOLORSUB0=tvenc[IHW_TVENC_COLORSUB0];	//LCDIFCTRL=lcdif[IHW_LCDIF_CTRL];	//LCDIFCTRL1=lcdif[IHW_LCDIF_CTRL1];//	while((lcdif[IHW_LCDIF_STAT] & 0x01000000));}void tvOff(void){unsigned long ctr;	while((lcdif[IHW_LCDIF_STAT] & 0x01000000));	ctr = lcdif[IHW_LCDIF_CTRL];	ctr=ctr & 0xFFF7FFFF;	lcdif[IHW_LCDIF_CTRL]=ctr;}	void tvOn(void){unsigned long ctr;	while((lcdif[IHW_LCDIF_STAT] & 0x01000000));	ctr = lcdif[IHW_LCDIF_CTRL];	ctr=ctr | 0x00080000;	lcdif[IHW_LCDIF_CTRL]=ctr;}//int delayAudio;int getRenderAudio(void){int ret=0,sts;/*	if(getCurrentTime()-delayAudio>600)	{		delayAudio=getCurrentTime();		return 1;	}	else	{	return 0;	} */	#if NOSOUND==1	return 0;#endif/*	sts=getStatusPlay();	if(sts==4)	{				printf("FPS sound %d\n",countSound);		countSound=0;		ret=1;	}	if(sts==3)	{			countSound++;	}	if(sts==2)	{			ret=1;	}	return ret;*/		sts=getStatusPlay();	if((sts==4) || (sts==2) || (sts==5))	{				//printf("FPS sound %d\n",countSound);		countSound=0;		ret=1;	}	if(sts==3)	{			countSound++;	}	return ret;	/*	if(statusDraw)  	{		if(countSound==0)	  	{			countSound=10; //5			ret=1;	  	}	  	countSound--;  	}		return ret;*/}/*=================================================F: Get Root path ===================================================*/char * getRootPath(void){	return ROOTPATH;}char * getDEMOPath(void){	return DEMOPATH;}/*=================================================F: Get List directory ===================================================*/int lastSDX=-1;char *listSDX[]={"/dev/sda1","/dev/sdb1","/dev/sdc1","/dev/sdd1","/dev/sde1","/dev/sdf1","/dev/sdg1","/dev/sdh1","/dev/sdi1","/dev/sdj1","/dev/sdk1","/dev/sdl1","/dev/sdm1","/dev/sdn1","/dev/sdo1","/dev/sdp1","/dev/sdq1","/dev/sdr1","/dev/sds1","/dev/sdt1","/dev/sdu1","/dev/sdv1","/dev/sdw1","/dev/sdx1","/dev/sdy1","/dev/sdz1"};char lastDEV[500];int getListFileDir(char *path,listDir *list) {     int i=0, files,ret,fd,j;     char patht[MAXPATH];     char strMount[1000];     struct dirent *entry;     DIR *dp;     int flgRoot=0;	     //int fmute=flagMute; 	 if(strcmp(path,ROOTPATH)==0) flgRoot=1;	 strcpy(patht,path);	// strcat(patht,"*");	if((strcmp(path,"/mnt/data/usb/")==0))	{		fd = open(lastDEV, O_RDWR ) ;		if(fd<0)		{			dp = opendir("/dev/");  			if (dp != NULL)			{				while((entry = readdir(dp)))	 			{	 				if(strstr(entry->d_name,"sd"))					{						strcpy(lastDEV,"/dev/");						strcat(lastDEV,entry->d_name);						sprintf(strMount,"mount %s /mnt/data/usb",lastDEV);							ret=system(strMount);						break;					}				}				closedir(dp);  			}		}							/*            	 	if(lastSDX<0) 		{			lastSDX=0;			fd=-1;					}		else			fd = open(listSDX[lastSDX], O_RDWR ) ;		if(fd<0)		{	for(lastSDX=0;lastSDX<25;lastSDX++)				if(open(listSDX[lastSDX], O_RDWR )>=0) break; 					if(lastSDX<25)			{				sprintf(strMount,"mount %s /mnt/data/usb",listSDX[lastSDX]);						ret=system(strMount);			}			else lastSDX=-1;		}	*/	}       	 //mute(0);	//if(flgRenderAudioPreview)	//WriteAudio((sample *)silenc,1000);  	dp = opendir(patht);  	if (dp == NULL)	{	    printf("PATH %s invalido \n",patht);	//if(fmute==0)		 //resumeMute();	//else	 //flagMute=fmute;	    return -1;	   strcpy(patht,ROOTPATH);	   strcpy(path,ROOTPATH);	   dp = opendir (patht);  	}       	 while((entry = readdir(dp)))	 {		//  printf("File %s\n",entry->d_name);		  if((entry->d_name[0]=='.') && (entry->d_name[1]!='.')) continue;		  list[i].type=0;  		  list[i].subType=0; 		  if((entry->d_name[0]=='.') && (entry->d_name[1]=='.'))		  {			if(strcmp(path,ROOTPATH)==0) continue;			strcpy(entry->d_name,"Voltar");			list[i].type=TYPE_BACKDIR;			list[i].subType=TBACK;		  }		  if(flgRoot)			  if(strcmp(entry->d_name,"usb")==0)				if(!checkPENDRIVE()) continue;				else				list[i].subType=TFUSB;         	  if(list[i].nameFile !=0) 		  {			//printf("Libera lista %s\n",list[i].nameFile);			free(list[i].nameFile);			list[i].nameFile=0;		  }		  list[i].nameFile=malloc(strlen(entry->d_name)+1); 		  strcpy(list[i].nameFile,entry->d_name);		 		  if(entry->d_type==DT_DIR)		  {			  if(list[i].type!=TYPE_BACKDIR)					list[i].type=TYPE_DIR;					if(list[i].subType==0)					list[i].subType=TFOLD;		  }		  else		  {			  list[i].type=TYPE_FILE;			  list[i].subType=getTypeFile(list[i].nameFile);		  }		  i++;		  if(i>=NUMMAXLIST) break;               };         closedir(dp);     qsort(list, i, sizeof(listDir), comp);	//if(fmute==0)		 //resumeMute();	//else	 //flagMute=fmute;     return(i);}/*============================================================ F: string compare to qsort	   ============================================================*/int comp(const void *s1, const void *s2){listDir *t1,*t2;	 t1=(listDir *)s1;	 t2=(listDir *)s2;	 if((t1->type==TYPE_BACKDIR))		 return -1;	 if((t2->type==TYPE_BACKDIR))		 return 1;		 return (strcmp(t1->nameFile,t2->nameFile) );	    }char *strtoupper(char *str){  char *string = str;  if(str){    for(; *str; ++str)      *str = toupper(*str);  }  return string;}/*============================================================ F: get Type file  ============================================================*/fileType getTypeFile(char *name){char *p; fileType ret = TFOTHER; char nameup[2048];/*	p = strrchr(name,'.');	if(p==0) return ret;	if((strcmp(p, ".gz")==0) || (strcmp(p, ".GZ")==0))	{		p = strchr(name,'.');	} */	//p=name;	strcpy(nameup,name);	p = strtoupper( nameup );		while(ret==TFOTHER)	{		p=strchr(p,'.');	if (p != 0)	{		if ((strcmp(p, ".bin") == 0) || 			(strcmp(p, ".bin.gz") == 0) ||			(strcmp(p, ".BIN") == 0) ||			(strcmp(p, ".BIN.GZ") == 0)) ret = TFGEN;		else if ((strcmp(p, ".bms") == 0) || 			(strcmp(p, ".bms.gz") == 0) ||			(strcmp(p, ".sms") == 0) ||			(strcmp(p, ".SMS") == 0) ||			(strcmp(p, ".sms.gz") == 0) ||			(strcmp(p, ".SMS.GZ") == 0) ||			(strcmp(p, ".BMS") == 0) ||			(strcmp(p, ".gg") == 0) ||			(strcmp(p, ".GG") == 0) ||			(strcmp(p, ".gg.gz") == 0) ||			(strcmp(p, ".GG.GZ") == 0) ||			(strcmp(p, ".sg") == 0) ||			(strcmp(p, ".SG") == 0) ||			(strcmp(p, ".sg.gz") == 0) ||			(strcmp(p, ".SG.GZ") == 0) ||			(strcmp(p, ".sc") == 0) ||			(strcmp(p, ".SC") == 0) ||			(strcmp(p, ".sc.gz") == 0) ||			(strcmp(p, ".SC.GZ") == 0) ||			(strcmp(p, ".sm") == 0) ||			(strcmp(p, ".SM") == 0) ||			(strcmp(p, ".sm.gz") == 0) ||			(strcmp(p, ".SM.GZ") == 0) ||			(strcmp(p, ".sf") == 0) ||			(strcmp(p, ".SF") == 0) ||			(strcmp(p, ".sf.gz") == 0) ||			(strcmp(p, ".SF.GZ") == 0) ||			(strcmp(p, ".BMS.GZ") == 0)) ret = TFSMS;		else if ((strcmp(p, ".bmp") == 0) || 			(strcmp(p, ".bmp.gz") == 0) ||			(strcmp(p, ".BMP") == 0) ||			(strcmp(p, ".BMP.GZ") == 0)) ret = TFBMP;		else if ((strcmp(p, ".mp3") == 0) ||			(strcmp(p, ".MP3") == 0)) ret = TFMP3;		else if ((strcmp(p, ".avi") == 0) ||			(strcmp(p, ".AVI") == 0) ||			(strcmp(p, ".flv") == 0) ||			(strcmp(p, ".FLV") == 0) ||			(strcmp(p, ".mov") == 0) ||			(strcmp(p, ".MOV") == 0) ||			(strcmp(p, ".mp4") == 0) ||			(strcmp(p, ".wmv") == 0) ||			(strcmp(p, ".WMV") == 0) ||			(strcmp(p, ".MP4") == 0)) ret = TFMP4;		else if ((strcmp(p, ".jpg") == 0) ||			(strcmp(p, ".JPG") == 0)) ret = TFJPG;			}	else if (name[0] != 0) ret = TFARM;	p++;	}	return ret;	}/*=================================================F: Exec file ===================================================*/pid_t pid=0;long countExec=0;int execFile(char *nameExec, char *name){int pi,ret;	if(pid>0) 	{	//ret=kill(pid, SIGQUIT);		ret=kill(pid, SIGKILL);		//printf("GUERTA ANTES WAIT %d %s \n",ret,name);			if(ret==0)		{			wait();  //SUPER IMPORTANTE EVITA FORMAÇAO DE PROCESSOS FILHOS ZUMBIS		//pid=0;			//printf("GUERTA DEPOIS WAIT\n");		}		if(strcmp(name,"nada")==0)		{	printf("GUERTA: Matando NADA\n");			return 0;		}		//else			//printf("GUERTA NAO TEM WAIT \n");	}	if ((pid = vfork()) == -1)        	printf("fork error");     	else if (pid == 0) {		if(strstr(nameExec,"mplayer"))		{			//pi=execlp(nameExec, nameExec, "-ao","alsa","-vo","fbdev2","-quiet","-vfm","ffmpeg","-lavdopts","lowres=1:fast:skiploopfilter=all",name,0);			 pi=execlp(nameExec, nameExec, "-ao","alsa","-vo","fbdev2","-ni","-vm","-x","320","-y","240",name,0);			//	pi=execlp(nameExec, nameExec, "-ao","alsa",name,0);		}		else if(strstr(nameExec,"mount"))		{			pi=execlp(nameExec, nameExec, name,"/mnt/data/usb",0); 		}		else		{			countExec++;			printf("GUERTA: Numero de execucoes %d - %s\n",countExec,name);			pi=execlp(nameExec, nameExec, name,0); 		}     	}	return pi;}int execFileNoKill(char *nameExec, char *nameFile){char str[4000];	sprintf(str,"%s %s",nameExec,nameFile);	system(str);}pixel *GetBufferPreview(void){	return (pixel *)(frameK+720*480);}void putVarMsgBox(void *p,int offset){ void **ps;  	ps=(void **)frameK;	ps+=720*480+offset;	*ps=p;}void * getVarMsgBox(int offset){ void **ps;  	ps=(void **)frameK;	ps+=720*480+offset;	return (*ps);}unsigned short copyBuffer[1000];void RenderAudioPreview(void){ unsigned short *ps;  int K;	flgRenderAudioPreview=1;	ps=(unsigned short *)frameK;	ps+=720*480*2*2;	K=*ps;	if(K)	{		*ps=0;		ps++;		memcpy(copyBuffer,ps,K*2);		WriteAudio((sample *)copyBuffer,K);	}	else	WriteAudio((sample *)silenc,200);}int stsPower=0;long timePower=0;		int checkStandBy(void){unsigned long ctr; int ret=0;	ctr=power[IHW_POWER_STS];	switch(stsPower)	{		case 0:		if((ctr & 0x00100000)==0x00100000)		{		 	stsPower=1;			timePower=getCurrentTime();		}					break;		case 1:		if((ctr & 0x00100000)==0) 		{	stsPower=0;  }		else		{			if(getCurrentTime()-timePower>1000)						{				stsPower=0;				ret=1;			}		}		break;	}	return ret;}int runStandBy(void){unsigned long ctr; int ret=0;	ctr=power[IHW_POWER_STS];	switch(stsPower)	{		case 0:		if((ctr & 0x00100000)==0) 		{	stsPower=1;  }		break;		case 1:		if((ctr & 0x00100000)==0x00100000) stsPower=2;		break;		case 2:		if((ctr & 0x00100000)==0) 		{	stsPower=0; ret=1; }		break;	}	return ret;}unsigned long CLKCTRL_FRAC;void setLowCPUConsume(void){unsigned long ctr;//	ctr=clkctrl[IHW_CLKCTRL_RESET];//	ctr|=0x20;//	clkctrl[IHW_CLKCTRL_RESET]=ctr;	system("poweroff -f");	while(1);	ctr=clkctrl[IHW_CLKCTRL_CPU];//	printf("CLK VELOCIDADE %x\n",ctr);	ctr&=0xFFFFFFC0;	ctr|=0x3F;	clkctrl[IHW_CLKCTRL_CPU]=ctr;		CLKCTRL_FRAC=clkctrl[IHW_CLKCTRL_FRAC];	ctr=CLKCTRL_FRAC & 0xFFC0FFFF;//	printf("CLK VELOCIDADE %x\n",ctr);	ctr|=0x001F0000;	clkctrl[IHW_CLKCTRL_FRAC]=ctr;}void setNormalCPUConsume (void){unsigned long ctr;	ctr=clkctrl[IHW_CLKCTRL_CPU];	ctr&=0xFFFFFFC0;	ctr|=1;	clkctrl[IHW_CLKCTRL_CPU]=ctr;	clkctrl[IHW_CLKCTRL_FRAC]=CLKCTRL_FRAC;}int checkPENDRIVE(void){     int i=0, files,ret=0,fd,j;     char patht[MAXPATH];     char strMount[1000];     struct dirent *entry;     DIR *dp;     //int fmute=flagMute;//	if(getCurrentTime()-timeUSBRecovery>1000)	{//		timeUSBRecovery=getCurrentTime();			fd = open(lastDEV, O_RDWR ) ;		if(fd<0)		{			dp = opendir("/dev/");  			if (dp != NULL)			{				while((entry = readdir(dp)))	 			{	 				if(strstr(entry->d_name,"sd"))					{												strcpy(patht,"/dev/");						strcat(patht,entry->d_name);						if(strcmp(patht,lastDEV)!=0)						{							//mute(0);						//if(flgRenderAudioPreview)						//WriteAudio((sample *)silenc,1000);							sprintf(strMount,"mount %s /mnt/data/usb",patht);						 //suspendPlay();							pausePlay();						//ret=system("umount /mnt/data/usb");							ret=system(strMount);							printf("Montando %s - %d - %s - %d\n",strMount,ret,strerror(errno),errno);							restorePausePlay();							if(ret==0)							{								strcpy(lastDEV,patht);								ret=1;							}							else							{								if(errno==12)								{	 ret=2;								}								else								{								ret=0; 							//	if(fmute==0)							//	 resumeMute();							//	else							//	 flagMute=fmute;								continue;								}							}							//if(fmute==0)							 //resumeMute();							//else							 //flagMute=fmute;						}						else						{							ret=1;							printf("MONTADO\n");						}						break;					}				}				closedir(dp);			}		}		else 		{	close(fd);			ret=1;			}	}	//printf("Return usb check %d\n",ret);	if(ret==0) strcpy(lastDEV,"");	return ret;}int checkJOY(void){	return kbfd;}#define VARPOSMPLAYER 0#define VARLENMPLAYER 1#define VARENDMPLAYER 2#define VARPAUSEMPLAYER 3int getPosMPlayer(void){int ret;	ret=(int)getVarMsgBox(VARPOSMPLAYER);	return ret;}int getLenMPlayer(void){int ret;	ret=(int)getVarMsgBox(VARLENMPLAYER);	return ret;}int getEndMPlayer(void){int ret;	ret=(int)getVarMsgBox(VARENDMPLAYER);	return ret;}void setPause(int flag){	putVarMsgBox(flag,VARPAUSEMPLAYER);	}void resetVarMPLayer(void){	putVarMsgBox(0,VARPAUSEMPLAYER);	putVarMsgBox(0,VARENDMPLAYER);	putVarMsgBox(0,VARLENMPLAYER);	putVarMsgBox(0,VARPOSMPLAYER);}int getIndexLastBar(char *name)
{int n;

/*	n=strlen(name);

	while(n>0)
	{
		if(name[n]=='/') break;
		n--;
	}

	return n++; */
	return 0;
}int m_z=1;
int m_w=1;

int myrand(void)
{

    m_z = 36969 * (m_z & 65535) + (m_z >> 16);
    m_w = 18000 * (m_w & 65535) + (m_w >> 16);
    return (m_z << 16) + m_w;


}//----------------------------------------------------------
// Sound interface
//---------------------------------------------------------

int SRenderAudio(void)
{
	return RenderAudio();

}

int SsetMusic(char *nameFile,int flgRepeat)
{
	return setMusic(nameFile,flgRepeat);
}

int SsetSoundChannel(char *nameFile,int channel,int flgRepeat)
{
	return setSoundChannel(nameFile,channel,flgRepeat);
}

int SfreeAudio(void)
{
	return freeAudio();
}

int SstartSound(tsound *snd)
{
	return startSound(snd);
}

int SstartSoundBuffer(sample *buf,long size)
{
	return startSoundBuffer(buf,size);
}

void SstartIDMusic(int id,int flgRepeat)
{
	startIDMusic(id,flgRepeat);
}